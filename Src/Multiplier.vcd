$date
	Sun Jan 14 21:56:25 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module Multiplier_tb $end
$var reg 1 ! en $end
$var reg 32 " oper_1 [31:0] $end
$var reg 32 # oper_2 [31:0] $end
$var reg 8 $ oper_3 [7:0] $end
$var reg 8 % oper_4 [7:0] $end
$var integer 32 & i [31:0] $end
$scope module uut $end
$var wire 1 ! enable $end
$var wire 32 ' operand_1 [31:0] $end
$var wire 32 ( operand_2 [31:0] $end
$var reg 1 ) adjacent_jump $end
$var reg 1 * adjacent_jump_1 $end
$var reg 4 + bit_inverted_1 [3:0] $end
$var reg 4 , bit_inverted_2 [3:0] $end
$var reg 3 - carry_bits [2:0] $end
$var reg 8 . carry_status [7:0] $end
$var reg 1 / is_negative $end
$var reg 1 0 is_negative_result $end
$var reg 4 1 neg [3:0] $end
$var reg 1 2 next_adjacent_jump $end
$var reg 1 3 next_adjacent_jump_1 $end
$var reg 8 4 operand_1_complement [7:0] $end
$var reg 16 5 partial_product_0 [15:0] $end
$var reg 16 6 partial_product_1 [15:0] $end
$var reg 16 7 partial_product_2 [15:0] $end
$var reg 16 8 partial_product_3 [15:0] $end
$var reg 32 9 product [31:0] $end
$var reg 8 : product_bits [7:0] $end
$var reg 16 ; result [15:0] $end
$var integer 32 < i [31:0] $end
$var integer 32 = j [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1000 =
b1000 <
b1110111000100100 ;
b10111000 :
b11111111111111111110111000100100 9
b1010111000000000 8
b11000000000000 7
b110000000000 6
b10000100100 5
b11011100 4
13
12
b0 1
00
1/
b11111100 .
b0 -
b111 ,
b1110 +
1*
1)
b10000001 (
b100100 '
b0 &
b10000001 %
b100100 $
b10000001 #
b100100 "
1!
$end
#1
b1101111011 9
b1101111011 ;
b1100010010100000 8
b11110111 4
1/
b10111011000000 7
b110000100100 6
b1111110111 5
10
b10010 :
02
0)
03
0*
b100 -
b11 ,
b1100 +
b101 1
b111 .
b1000 =
b1000 <
b1100011 #
b1100011 (
b1001 "
b1001 '
b1100011 %
b1001 $
b1 &
#2
b11111111111111111111101000101001 9
b1111101000101001 ;
b1011100110000000 8
b11110011 4
1/
b11000011010000 7
b101111001100 6
b10000001101 5
00
12
1*
b11100110 :
13
1)
b0 -
b111 ,
b1000 +
b10 1
b11111111 .
b1000 =
b1000 <
b10001101 #
b10001101 (
b1101 "
b1101 '
b10001101 %
b1101 $
b10 &
#3
b11100011010 9
b11100011010 ;
b1100000000000000 8
b10011011 4
1/
b11011001010000 7
b110110010110 6
b1100110100 5
00
12
0)
b0 :
03
1*
b1 -
b1 1
b1110 ,
b1001 +
b11111111 .
b1000 =
b1000 <
b10010 #
b10010 (
b1100101 "
b1100101 '
b10010 %
b1100101 $
b11 &
#4
b1101 9
b1101 ;
b11111111 4
1/
b11000000010000 7
b101111111100 6
00
b10000000001 5
b0 :
12
13
0*
0)
b0 -
b10 1
b1111 ,
b1000 +
b111 .
b1000 =
b1000 <
b1101 #
b1101 (
b1 "
b1 '
b1101 %
b1 $
b100 &
#5
b1110000011110 9
b1110000011110 ;
b1101110110000000 8
b10001110 4
1/
b11000000001000 7
b101000100000 6
00
b10001110110 5
03
1*
b1110110 :
12
0)
b100 +
b10 -
b11111100 .
b1000 =
b1000 <
b111101 #
b111101 (
b1110110 "
b1110110 '
b111101 %
b1110110 $
b101 &
#6
b100010011100 9
b100010011100 ;
b1100100110000000 8
b10011 4
1/
b10111011010000 7
10
b110001001100 6
b10000000000 5
b100110 :
02
03
0*
0)
b10 1
b111 ,
b0 -
b1001 +
b11111111 .
b1000 =
b1000 <
b10001100 #
b10001100 (
b11101101 "
b11101101 '
b10001100 %
b11101101 $
b110 &
#7
b110010110 9
b110010110 ;
b1100000111000000 8
b111 4
1/
b11000000000000 7
b101111001010 6
b10000001100 5
00
03
0*
b111 :
02
0)
b111 +
b1 -
b1 1
b1100 ,
b11110111 .
b1000 =
b1000 <
b11000110 #
b11000110 (
b11111001 "
b11111001 '
b11000110 %
b11111001 $
b111 &
#8
b1001111010010 9
b1001111010010 ;
b1100111011000000 8
b111011 4
1/
b11001110110000 7
b110011101110 6
b10001110100 5
b111011 :
13
0*
12
0)
b111 1
b1110 ,
b1 +
b11111111 .
b1000 =
b1000 <
b10101010 #
b10101010 (
b11000101 "
b11000101 '
b10101010 %
b11000101 $
b1000 &
#9
b11111111111111111111001101110011 9
b1111001101110011 ;
b1011001010000000 8
b11011 4
1/
b11000110110000 7
b101100101000 6
00
b10000011011 5
12
1*
b11001010 :
13
1)
b101 1
b0 -
b101 ,
b1010 +
b11111111 .
b1000 =
b1000 <
b1110111 #
b1110111 (
b11100101 "
b11100101 '
b1110111 %
b11100101 $
b1001 &
#10
b1010 &
